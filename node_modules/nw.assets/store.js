var _ = require('underscore'),
    async = require('async'),
    url = require('url'),
    path = require('path'),
    crypto = require('crypto'),
    Inline = require('./inline');

var explicitRegex = /\.js$|\.css$/;

var BufferStream = function (buffer, opts) {
    if (!(this instanceof BufferStream)) {
        return new BufferStream(buffer, opts);
    }
    Stream.call(this);

    if (_.isObject(buffer)) {
        opts = buffer;
        buffer = null;
    }

    _.extend(this, {
        bufferSize: 64 * 1024,
        paused: false,
        pos: 0,
        buffer: buffer
    }, opts);
    this.reading = false;

    this._read();
};
util.inherits(BufferStream, Stream);

BufferStream.prototype.pause = function () {
    this.paused = true;
};

BufferStream.prototype.resume = function () {
    this.paused = false;
    this._read();
};

BufferStream.prototype._read = function () {
    var self = this;
    if (this.reading || this.paused || !this.buffer) {
        return;
    }

    this.reading = true;
    nextTick(function () {
        self.reading = false;
        if (self.paused) {
            return;
        }

        var d = self.buffer.slice(self.pos, self.pos + self.bufferSize);
        self.pos += d.length;
        if (d.length === 0) {
            self.emit('end');
        } else {
            self.emit('data', d);
            self._read();
        }
    });
};

var ConcatStream = function (sources, opts) {
    if (!(this instanceof ConcatStream)) {
        return new ConcatStream(sources, opts);
    }
    Stream.call(this);

    _.extend(this, {
        paused: false,
        sources: sources
    }, opts);
    this.reading = false;

    if (!this.paused) {
        this._next();
    }
};
util.inherits(ConcatStream, Stream);

ConcatStream.prototype.pause = function () {
    this.paused = true;
    this.sources && this.sources[0] && this.sources[0].pause();
};

ConcatStream.prototype.resume = function () {
    this.paused = false;
    this.sources && this.sources[0] && this.sources[0].resume();
};

ConcatStream.prototype._next = function () {
    var self = this;
    
    if (!this.sources) {
        this.emit('end');
        return;
    }

    var source = this.sources[0];
    if (!source) {
        this.emit('end');
        return;
    }

    source.resume();
    source.on('data', function (data) {
        self.emit('data', data);
    });
    source.on('error', function (err) {
        self.emit('error', err);
    });
    source.on('end', function () {
        self.sources = self.sources.slice(1);
        self._next();
    });
};

function Source (input) {
    if (_.isObject(input) && !_.isFunction(input)) {
        return input;
    }

    var source = {};

    source.urls = function (store) {
        return null;
    };

    source.stream = function (store) {
        if (_.isFunction (input)) {
            var stream = new BufferStream();
            input(store, function (data) {
                stream.buffer = data;
                stream.resume();
            });
            return stream;
        } else {
            return fs.createReadStream(input, {
                encoding: 'utf8'
            });
        }
    };

    return source;
};

function FromStore (url) {
    var source = {};

    source.urls = function (store) {
        return [url];
    };

    source.stream = function (store) {
        store.source(url).stream(store);
    };

    return source;
};

function Concat (inputs) {
    var source = {};
    var sources = _.map(inputs, Source);

    source.urls = function (store) {
        return _.flatten(_.map(sources, function (source) {
            return source.urls(store);
        }), true);
    };

    source.stream = function (store) {
        return new ConcatStream(_.map(sources, function (source) {
            return source.stream(store);
        }));
    };
};

// stub
function Uglify (input) {
    var source = {};
    input = Source(input);

    source.urls = function (store) {
        return input.urls(store);
    };

    source.stream = function (store) {
        return input.stream(store);
    };

    return source;
};

module.exports = function (opts) {
    opts = _.extend({
        compile: true,
        output: null
    }, opts);

    if (!opts.output) {
        throw new Error('store output must be specified');
    }

    var store = {};
    var assets = {};

    store.publish = function (url, source) {
        store.register(url, source, true);
    };

    store.register = function (url, source, publish) {
        source = Source(source);

        assets[url] = source;
        if (publish) {
            var write = fs.createWriteStream(path.join(opts.output, url), {
                encoding: 'utf8',
            });

            source.stream(store).pump(write);
        }
    };

    store.asset = function (url) {
        return assets[url];
    };

    /* move to context extensions
     *
    store.getPackageIncludeTags = function (name) {
        //
    };

    store.getAssetIncludeTags = function () {
        var assets = arguments;
        //
    };

    store.templateContext = function () {
        return {
            package: _.bind(store.getPackageIncludeTags, store),
            asset: _.bind(store.getAssetIncludeTags, store)
        };
    };
    */

    function addAssetDir (baseUrl, dir) {
        if (baseUrl[baseUrl.length-1] !== '/') {
            baseUrl += '/';
        }
        if (dir([dir.length-1] !== '/') {
            dir += '/';
        }

        utils.fsFind(dir, function (entries) {
            _.each(entries, function (entry) {
                store.add(baseUrl+entry, dir+entry);
            });
        });
    }

    function copyAsset (url, asset) {
        var newPath = path.join(opts.output, url);
        utils.ensureDirExist(path.basename(newPath), function () {
            utils.copyFile(newPath, asset);
        });
    }

    function saveAsset (url, asset) {
        explicitAssets[url] = asset;
    }
};
