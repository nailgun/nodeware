var _ = require('underscore'),
    async = require('async'),
    path = require('path');

function Cache (connection, opts) {
    var cache = {
        trust: opts.trust,
        mtime: opts.mtime
    };

    var prefix = opts.prefix;
    if (prefix.length != 0 && prefix[prefix.length-1] !== '/') {
        prefix += '/';
    }

    var trustedKeys = {};

    cache.namespace = function () {
        return prefix;
    };

    cache.get = function (key, callback) {
        if (!cache.trust && !trustedKeys[key]) {
            callback(undefined);
        } else {
            var key = path.join(prefix, key);
            if (!cache.mtime) {
                connection.get(key, callback);
            } else {
                async.parallel([function (callback) {
                    connection.get(key, function (value) {
                        callback(null, value);
                    })
                }, function (callback) {
                    connection.get(key+'.mtime', function (value) {
                        callback(null, value);
                    })
                }], function (err, results) {
                    var value = results[0];
                    var mtime = results[1];
                    if (typeof value !== 'undefined') {
                        if (mtime) {
                            mtime = new Date(parseInt(mtime));
                        } else {
                            mtime = new Date();
                        }
                    } else {
                        mtime = undefined;
                    }
                    callback(value, mtime);
                });
            }
        }
    };

    cache.set = function (key, value, callback) {
        trustedKeys[key] = 1;
        var key = path.join(prefix, key);

        if (!cache.mtime) {
            connection.set(key, value, callback);
        } else {
            async.parallel([function (callback) {
                connection.set(key, value, function () {
                    callback(null);
                })
            }, function (callback) {
                connection.set(key+'.mtime', new Date().getTime(), function () {
                    callback(null);
                })
            }], function () {
                callback();
            });
        }
    };

    cache.invalidate = function (key, callback) {
        delete trustedKeys[key];
        connection.invalidate(path.join(prefix, key), callback);
    };

    cache.subCache = function () {
        var newPrefix = path.join(prefix, Array.prototype.join.call(arguments, '/'));
        return Cache(connection, {
            mtime: cache.mtime,
            trust: cache.trust,
            prefix: newPrefix
        });
    };

    return cache;
};

exports.create = function () {
    var args = arguments;
    var callback = args[args.length-1];
    if (typeof callback !== 'function') {
        throw new Error('expected callback as last parameter');
    }
    var opts = {};
    var prefixParts = [];
    if (args.length > 1) {
        opts = args[args.length-2];
        if (typeof opts !== 'object') {
            opts = {};
            prefixParts = Array.prototype.slice.call(args, 0, -1);
        } else {
            prefixParts = Array.prototype.slice.call(args, 0, -2);
        }
    }
    opts = _.extend({
        backend: 'local',
        trust: true,
        mtime: false
    }, opts);
    if (opts.prefix) {
        prefixParts.unshift(opts.prefix);
    }
    opts.prefix = prefixParts.join('/');

    var backendModule = require('./backends/'+opts.backend);

    backendModule(opts, function (connection) {
        callback(Cache(connection, opts));
    });
};
