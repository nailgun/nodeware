(function () {

if (typeof module !== 'undefined') {
    module.exports = exports;

    var _ = require('underscore'),
        async = require('async');
} else {
    window.nw = window.nw || {};
    exports = window.nw.forms;
}

function ValidationError(code, messageMap) {
    return {
        code: code,
        message: messageMap[code],
    };
}

exports.BaseField = function (opts) {
    var defaults = {
        required: true,
        validators: [],
        errorMessages: {
            'required': 'this field is required',
            'invalid': 'enter a valid value',
        }
    };
    if (opts) {
        _.extend(defaults.errorMessages, opts.errorMessages);
    }

    var field = _.extend(defaults, opts);

    field.parse = function (raw_data, callback) {
        callback(null, raw_data);
    };

    field.validate = function (value, callback) {
        if ((value === '' || value === null || typeof value === 'undefined') && field.required) {
            callback(ValidationError('required', field.errorMessages));
        } else {
            callback(null);
        }
    };

    field.bind = function (raw_data) {
        return bind(field, raw_data);
    };

    return field;
};

function bind (field, raw_data) {
    var bound = _.extend({
        raw_data: raw_data
    }, field);

    bound.clean = function (callback) {
        // 3 steps to clean field
        async.waterfall([function (callback) {
            // 1. parse field
            bound.parse(bound.raw_data, callback);

        }, function (value, callback) {
            // 2. run field validator
            bound.validate(value, function (err) {
                callback (err, value);
            });

        }, function (value, callback) {
            // 3. run all attached validators
            var validatorErrors = [];
            async.forEachSeries(bound.validators, function (validator, callback) {
                validator(value, function (err) {
                    if (err) {
                        if ('code' in err && err.code in bound.errorMessages) {
                            err.message = bound.errorMessages[err.code];
                        }
                        validatorErrors.push(err);
                    }
                    callback();
                });
            }, function () {
                if (validatorErrors.length) {
                    callback(validatorErrors, value);
                } else {
                    callback(null, value);
                }
            });

        }], function (err, value) {
            if (err) {
                if (typeof err !== 'array') {
                    err = [err];
                }
            }

            callback(err, value);
        })
    };

    return bound;
};

exports.StringField = function (opt) {
    var field = exports.BaseField(opt);
    field.parse = function (raw_data, callback) {
        if (typeof raw_data !== 'undefined' && raw_data !== null) {
            callback(null, String(raw_data));
        } else {
            callback(null, '');
        }
    };
    return field;
};

exports.NumberField = function (opt) {
    var field = exports.BaseField(opt);
    field.parse = function (raw_data, callback) {
        if (raw_data === null || raw_data === '' || typeof raw_data === 'undefined') {
            callback(null, null);
        } else {
            var value = Number(raw_data);
            if (isNaN(value)) {
                callback(ValidationError('invalid', field.errorMessages));
            } else {
                callback(null, value);
            }
        }
    };
    return field;
};

exports.BooleanField = function (opt) {
    var field = exports.BaseField(opt);
    field.parse = function (raw_data, callback) {
        callback(null, Boolean(raw_data));
    };
    return field;
};

exports.DateTimeField = function (opt) {
    var field = exports.BaseField(opt);
    field.parse = function (raw_data, callback) {
        if (raw_data === null || raw_data === '' || typeof raw_data === 'undefined') {
            callback(null, null);
        } else {
            var value = new Date(raw_data);
            if (isNaN(value)) {
                callback(ValidationError('invalid', field.errorMessages));
            } else {
                callback(null, value);
            }
        }
    }
    return field;
}

})();
